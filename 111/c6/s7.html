<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Javanotes 5.1.2, Section 6.7 -- Basic Layout</title>
<link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
<small>
        [  <a href="s6.html">Previous Section</a> |
           <a href="s8.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
<tr>
<td>
<div align="center">
<b>Subsections</b>
<hr>
<small><a href="#GUI1.7.1">Basic Layout Managers</a>
<br>
<a href="#GUI1.7.2">Borders</a>
<br>
<a href="#GUI1.7.3">SliderAndComboBoxDemo</a>
<br>
<a href="#GUI1.7.4">A Simple Calculator</a>
<br>
<a href="#GUI1.7.5">Using a null Layout</a>
<br>
<a href="#GUI1.7.6">A Little Card Game</a>
<br>
</small>
</div>
</td>
</tr>
</table>
<div class="content">
<h3 class="section_title">Section 6.7</h3>
<h2 class="section_title">Basic Layout</h2>
<hr class="break">


<p>
<span class="start"><big>C</big>omponents</span> are the fundamental building blocks
of a graphical user interface.  But you have to do more with components besides create them.
Another aspect of GUI programming is <span class="newword">laying out</span> components on the screen,
that is, deciding where they are drawn and how big they are. You have probably
noticed that computing coordinates can be a difficult problem, especially if
you don't assume a fixed size for the drawing area. Java has a solution for this, as
well.</p>


<p>Components are the visible objects that make up a GUI. Some components are
<span class="newword">containers</span>, which can hold other components.  Containers in
Java are objects that belong to some subclass of <span class="code">java.awt.Container</span>.
The content pane
of a <span class="classname">JApplet</span> or <span class="classname">JFrame</span>
is an example of a container. The standard class
<span class="classname">JPanel</span>, which we have mostly used as a drawing surface up till now, is
another example of a container.</p>


<p>Because a <span class="classname">JPanel</span> object is a
container, it can hold other components.  Because a
<span class="classname">JPanel</span> is itself a component, you can add a <span class="classname">JPanel</span> 
to another <span class="classname">JPanel</span>. This makes complex
nesting of components possible. <span class="classname">JPanels</span> can be used to organize
complicated user interfaces, as shown in this illustration:</p>


<p align="center">
<img src="nested_panels.png" width="283" height="270" alt=""></p>   


<p>The components in a container must be "laid out," which means setting their
sizes and positions. It's possible to program the layout yourself, but
ordinarily layout is done by a <span class="newword">layout manager</span>. A
layout manager is an object associated with a container that implements some
policy for laying out the components in that container. Different types of
layout manager implement different policies.  In this section, we will cover
the three most common types of layout manager, and then we will look at
several programming examples that use components and layout.</p>


<p>Every container has an instance method, <span class="code">setLayout()</span>, that takes
a parameter of type <span class="classname">LayoutManager</span> and that is used to specify
the layout manager that will be responsible for laying out any components that
are added to the container.  Components are added to a container by calling
an instance method named <span class="code">add()</span> in the container object.  There
are actually several versions of the <span class="code">add()</span> method, with different
parameter lists.  Different versions of <span class="code">add()</span> are appropriate
for different layout managers, as we will see below.</p>
   
   

<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.1">6.7.1&nbsp;&nbsp;Basic Layout Managers</a>
</h3>


<p>Java has a variety of standard layout managers that
can be used as parameters in the <span class="code">setLayout()</span> method.  They are defined by
classes in the package <span class="code">java.awt</span>.  Here, we will look at
just three of these layout manager classes: <span class="classname">FlowLayout</span>,
<span class="classname">BorderLayout</span>, and <span class="classname">GridLayout</span>.
</p>
   

<p>A <span class="classname">FlowLayout</span> simply lines up components in a row across the
container.  The size of each component is equal to that component's "preferred size."
After laying out as many items as will fit in a row
across the container, the layout manager will move on to the next row.
The default layout for a <span class="classname">JPanel</span> is a
<span class="classname">FlowLayout</span>;  that is, a <span class="classname">JPanel</span> uses a
<span class="classname">FlowLayout</span> unless you specify a different layout manager by
calling the panel's <span class="code">setLayout()</span> method.</p>
   

<p>The components in a given row can be either left-aligned, right-aligned, or centered within
that row, and there can be horizontal and vertical gaps between components. If the default constructor,
"<span class="code">new FlowLayout()</span>", is used, then the components on each row will be centered
and both the horizontal and the vertical gaps will be five pixels.  The constructor</p>


<pre>public FlowLayout(int align, int hgap, int vgap)</pre>


<p>can be used to specify alternative alignment and gaps. The possible values
of <span class="code">align</span> are <span class="code">FlowLayout.LEFT</span>, <span class="code">FlowLayout.RIGHT</span>, and
<span class="code">FlowLayout.CENTER</span>.</p>
   

<p>Suppose that <span class="code">cntr</span> is a container object that is using a <span class="classname">FlowLayout</span>
as its layout manager.  Then, a component, <span class="code">comp</span>, can be added to the container with
the statement</p>
  

<pre>cntr.add(comp);</pre>
   

<p>The <span class="classname">FlowLayout</span> will line up all the components that have been
added to the container in this way.  They will be lined up in the order in which they
were added.  For example, this picture shows five buttons in a panel that uses
a <span class="classname">FlowLayout</span>:</p>


<p align="center">
<img src="FlowLayoutDemo.png" width="476" height="90" alt=""></p>
   

<p>Note that since the five buttons will not fit in a single row across the panel,
they are arranged in two rows.  In each row, the buttons are grouped together and are
centered in the row.  The buttons were added to the panel using the statements:</p>
   

<pre>panel.add(button1);
panel.add(button2);
panel.add(button3);
panel.add(button4);
panel.add(button5);</pre>
   

<p>When a container uses a layout manager, the layout manager is ordinarily responsible
for computing the preferred size of the container (although a different preferred size
could be set by calling the container's <span class="code">setPreferredSize</span> method).  A
<span class="classname">FlowLayout</span> prefers to put its components in a single row,
so the preferred width is the total of the preferred widths of all the components, plus
the horizontal gaps between the components.  The preferred height is the maximum
preferred height of all the components.</p>


<hr class="break">
   

<p>A <span class="classname">BorderLayout</span> layout manager is designed to display
one large, central component, with up to four smaller components arranged along
the edges of the central component.  If a container, <span class="code">cntr</span>, is
using a <span class="classname">BorderLayout</span>, then a component, <span class="code">comp</span>,
should be added to the container using a statement of the form</p>
   

<pre>cntr.add( comp, borderLayoutPosition );</pre>
   

<p>where <span class="code">borderLayoutPosition</span> specifies what position the component
should occupy in the layout and is given as one of the constants
<span class="code">BorderLayout.CENTER</span>, <span class="code">BorderLayout.NORTH</span>, 
<span class="code">BorderLayout.SOUTH</span>, <span class="code">BorderLayout.EAST</span>, 
or <span class="code">BorderLayout.WEST</span>.  The meaning of the five
positions is shown in this diagram:</p>
   

<p align="center">
<img src="border_layout.png" width="216" height="170" alt=""></p>   


<p>Note that a border layout can contain fewer than five components,
so that not all five of the possible positions need to be filled.</p>
   

<p>A <span class="classname">BorderLayout</span> selects the sizes of its components
as follows:  The <span class="code">NORTH</span> and <span class="code">SOUTH</span> components (if
present) are shown at their preferred heights, but their width is set equal
to the full width of the container.  The <span class="code">EAST</span> and <span class="code">WEST</span>
components are shown at their preferred widths, but their height is set
to the height of the container, minus the space occupied by the <span class="code">NORTH</span>
and <span class="code">SOUTH</span> components.  Finally, the <span class="code">CENTER</span> component
takes up any remaining space; the preferred size of the <span class="code">CENTER</span>
component is completely ignored.  You should make sure that the components
that you put into a <span class="classname">BorderLayout</span> are suitable for the
positions that they will occupy.  A horizontal slider or text field, for example,
would work well in the <span class="code">NORTH</span> or <span class="code">SOUTH</span> position, but
wouldn't make much sense in the <span class="code">EAST</span> or <span class="code">WEST</span> position.</p>



<p>The default constructor, <span class="code">new BorderLayout()</span>, leaves no space
between components.  If you would like to leave some space,
you can specify horizontal and vertical gaps in the constructor of the
<span class="code">BorderLayout</span> object. For example, if you say</p>


<pre>panel.setLayout(new BorderLayout(5,7));</pre>


<p>then the layout manager will insert horizontal gaps of 5 pixels between
components and vertical gaps of 7 pixels between components. The background
color of the container will show through in these gaps.  The default layout for
the original content pane that comes with a <span class="classname">JFrame</span> or 
<span class="classname">JApplet</span>
is a <span class="code">BorderLayout</span> with no horizontal or vertical gap.</p>
   

<hr class="break">


<p>Finally, we consider the <span class="classname">GridLayout</span> layout manager.
A grid layout lays out components in a grid of equal
sized rectangles. This illustration shows how the components would be arranged
in a grid layout with 3 rows and 2 columns:</p>
   

<p align="center">
<img src="grid_layout.png" width="155" height="149" alt=""></p>   
   

<p>If a container uses a
<span class="classname">GridLayout</span>, the appropriate <span class="code">add</span> method for the container
takes a single parameter of type <span class="classname">Component</span> (for example: 
<span class="code">cntr.add(comp)</span>).  Components are added to the grid in the order shown;
that is, each row is filled from left to right before going on the next row.</p>


<p>The constructor for a <span class="classname">GridLayout</span> takes the form 
"<span class="code">new GridLayout(R,C)</span>", where <span class="code">R</span> is the number of rows
and <span class="code">C</span> is the number of columns. If you want
to leave horizontal gaps of <span class="code">H</span> pixels between columns and vertical gaps
of <span class="code">V</span> pixels between rows, use "<span class="code">new GridLayout(R,C,H,V)</span>"
instead.</p>


<p>When you use a <span class="classname">GridLayout</span>, it's probably good form to add just
enough components to fill the grid. However, this is not required. In fact, as
long as you specify a non-zero value for the number of rows, then the number of
columns is essentially ignored. The system will use just as many columns as are
necessary to hold all the components that you add to the container. If you want
to depend on this behavior, you should probably specify zero as the number of
columns. You can also specify the number of rows as zero. In that case, you
must give a non-zero number of columns. The system will use the specified
number of columns, with just as many rows as necessary to hold the components
that are added to the container.</p>


<p>Horizontal grids, with a single row, and vertical grids, with a single
column, are very common. For example, suppose that <span class="code">button1</span>,
<span class="code">button2</span>, and <span class="code">button3</span> are buttons and that you'd like to
display them in a horizontal row in a panel. If you use a horizontal grid for
the panel, then the buttons will completely fill that panel and will all be the
same size.  The panel can be created as follows:</p>


<pre>JPanel buttonBar = new JPanel();
buttonBar.setLayout( new GridLayout(1,3) );
    // (Note:  The "3" here is pretty much ignored, and
    //  you could also say "new GridLayout(1,0)".
    //  To leave gaps between the buttons, you could use
    //  "new GridLayout(1,0,5,5)".)
buttonBar.add(button1);
buttonBar.add(button2);
buttonBar.add(button3);</pre>


<p>You might find this button bar to be more attractive than the one
that uses the default <span class="classname">FlowLayout</span> layout manager.</p>






<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.2">6.7.2&nbsp;&nbsp;Borders</a>
</h3>
   

<p>We have seen how to leave gaps between the components in a container, but what
if you would like to leave a border around the outside of the container?  This
problem is not handled by layout managers.  Instead, borders in Swing are represented
by objects.  A <span class="classname">Border</span> object can be added to any <span class="classname">JComponent</span>,
not just to containers. Borders can be more than just empty space.
The class <span class="code">javax.swing.BorderFactory</span> contains a
large number of static methods for creating border objects. For example, the
function</p>


<pre>BorderFactory.createLineBorder(Color.BLACK)</pre>


<p>returns an object that represents a one-pixel wide black line around the
outside of a component. If <span class="code">comp</span> is a <span class="code">JComponent</span>, a border can
be added to <span class="code">comp</span> using its <span class="code">setBorder()</span> method. For
example:</p>


<pre>comp.setBorder( BorderFactory.createLineBorder(Color.BLACK) );</pre>


<p>When a border has been set for a <span class="code">JComponent</span>, the border is drawn
automatically, without any further effort on the part of the programmer. The
border is drawn along the edges of the component, just inside its boundary. The
layout manager of a <span class="code">JPanel</span> or other container will take the space
occupied by the border into account. The components that are added to the
container will be displayed in the area inside the border. I don't recommend
using a border on a <span class="code">JPanel</span> that is being used as a drawing surface.
However, if you do this, you should take the border into account. If you draw
in the area occupied by the border, that part of your drawing will be covered
by the border.</p>


<p>Here are some of the static methods that can be used to create borders:</p>


<ul>

<li>
<span class="codedef">BorderFactory.createEmptyBorder(top,left,bottom,right)</span>
 --  leaves an empty border around the edges of a component. Nothing is drawn in
this space, so the background color of the component will appear in the area occupied by the
border. The parameters are integers that give the width of the border along the
top, left, bottom, and right edges of the component. This is actually very
useful when used on a <span class="classname">JPanel</span> that contains other components. It puts
some space between the components and the edge of the panel.  It can also be
useful on a <span class="classname">JLabel</span>, which otherwise would not have any
space between the text and the edge of the label.</li>


<li>
<span class="codedef">BorderFactory.createLineBorder(color,thickness)</span>  -- 
draws a line around all four edges of a component. The first parameter is of
type <span class="classname">Color</span> and specifies the color of the line. The second parameter
is an integer that specifies the thickness of the border. If the second
parameter is omitted, a line of thickness 1 is drawn.</li>


<li>
<span class="codedef">BorderFactory.createMatteBorder(top,left,bottom,right,color)</span>
 --  is similar to <span class="code">createLineBorder</span>, except that you can specify
individual thicknesses for the top, left, bottom, and right edges of the
component.</li>


<li>
<span class="codedef">BorderFactory.createEtchedBorder()</span>
 --  creates a border that looks like a groove etched around the boundary of the
component. The effect is achieved using lighter and darker shades of the
component's background color, and it does not work well with every background
color.</li>


<li>
<span class="codedef">BorderFactory.createLoweredBevelBorder()</span> -- gives a
component a three-dimensional effect that makes it look like it is lowered into
the computer screen. As with an EtchedBorder, this only works well for certain
background colors.</li>


<li>
<span class="codedef">BorderFactory.createRaisedBevelBorder()</span> -- similar
to a LoweredBevelBorder, but the component looks like it is raised above the
computer screen.</li>


<li>
<span class="codedef">BorderFactory.createTitledBorder(title)</span> -- creates a
border with a title. The title is a <span class="classname">String</span>, which is displayed in the
upper left corner of the border.</li>

</ul>


<p>There are many other methods in the <span class="code">BorderFactory</span> class, most of
them providing variations of the basic border styles given here. The following
illustration shows six components with six different border styles. The text in each
component is the command that created the border for that component:</p>


<p align="center">
<img src="BorderDemo.png" width="401" height="355" alt=""></p>


<p>(The source code for the applet that produced this picture can be found
in <span class="sourceref"><a href="../source/BorderDemo.java">BorderDemo.java</a></span>.)</p>



   

<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.3">6.7.3&nbsp;&nbsp;SliderAndComboBoxDemo</a>
</h3>


<p>Now that we have looked at components and layouts, it's time to put
them together into some complete programs.  We start with a simple demo
that uses a <span class="classname">JLabel</span>, a <span class="classname">JComboBox</span>,
and a couple of <span class="classname">JSliders</span>, all laid out in a
<span class="classname">GridLayout</span>:</p>


<p align="center">
<applet code="SliderAndComboBoxDemo.class" width="240" height="142" archive="SliderAndComboBoxDemo.jar" alt="Applet 'SliderAndComboBoxDemo' should appear here"></applet></p>
   

<p>The sliders in this applet control the foreground and background color of the label,
and the combo box controls its font style.  Writing this program is a matter of creating
the components, laying them out, and programming listeners to respond to events
from the sliders and combo box.  In my program, I define a subclass of <span class="classname">JPanel</span>
which will be used for the applet's content pane.  This class implements
<span class="classname">ChangeListener</span> and <span class="classname">ActionListener</span>, so the
panel itself can act as the listener for change events from the sliders and action events from the combo box.
In the constructor, the four components are created and configured,
a <span class="classname">GridLayout</span> is installed as the layout manager for
the panel, and the components are added to the panel:</p>

   

<pre>/* Create the sliders, and set up this panel to listen for
   ChangeEvents that are generated by the sliders. */

bgColorSlider = new JSlider(0,255,100);
bgColorSlider.addChangeListener(this);

fgColorSlider = new JSlider(0,255,200);
fgColorSlider.addChangeListener(this);
 
/* Create the combo box, and add four items to it, listing
   different font styles.  Set up the panel to listen for
   ActionEvents from the combo box. */
 
fontStyleSelect = new JComboBox();
fontStyleSelect.addItem("Plain Font");
fontStyleSelect.addItem("Italic Font");
fontStyleSelect.addItem("Bold Font");
fontStyleSelect.addItem("Bold Italic Font");
fontStyleSelect.setSelectedIndex(2);
fontStyleSelect.addActionListener(this);

/* Create the display label, with properties to match the
   values of the sliders and the setting of the combo box. */

displayLabel = new JLabel("Hello World!", JLabel.CENTER);
displayLabel.setOpaque(true);
displayLabel.setBackground( new Color(100,100,100) );
displayLabel.setForeground( new Color(255, 200, 200) );
displayLabel.setFont( new Font("Serif", Font.BOLD, 30) );

/* Set the layout for the panel, and add the four components. 
   Use a GridLayout with 4 rows and 1 column. */

setLayout(new GridLayout(4,1));
add(displayLabel);
add(bgColorSlider);
add(fgColorSlider);
add(fontStyleSelect);</pre>
   

<p>The class also defines the methods required by the <span class="classname">ActionListener</span>
and <span class="classname">ChangeListener</span> interfaces.  The <span class="code">actionPerformed()</span>
method is called when the user selects an item in the combo box.  This method changes
the font in the <span class="classname">JLabel</span>, where the font depends on which item
is currently selected in the combo box, <span class="code">fontStyleSelect</span>:</p>
   

<pre>public void actionPerformed(ActionEvent evt) {
   switch ( fontStyleSelect.getSelectedIndex() ) {
   case 0:
      displayLabel.setFont( new Font("Serif", Font.PLAIN, 30) );
      break;
   case 1:
      displayLabel.setFont( new Font("Serif", Font.ITALIC, 30) );
      break;
   case 2:
      displayLabel.setFont( new Font("Serif", Font.BOLD, 30) );
      break;
   case 3:
      displayLabel.setFont( new Font("Serif", Font.BOLD + Font.ITALIC, 30) );
      break;
   }
}</pre>
   

<p>And the <span class="code">stateChanged()</span> method, which is called when the user
manipulates one of the sliders, uses the value on the slider to compute a new
foreground or background color for the label.  The method checks
<span class="code">evt.getSource()</span> to determine which slider was changed:</p>
   

<pre>public void stateChanged(ChangeEvent evt) {
   if (evt.getSource() == bgColorSlider) {
      int bgVal = bgColorSlider.getValue();
      displayLabel.setBackground( new Color(bgVal,bgVal,bgVal) );
         // NOTE:  The background color is a shade of gray,
         //        determined by the setting on the slider.
   }
   else {
      int fgVal = fgColorSlider.getValue();
      displayLabel.setForeground( new Color( 255, fgVal, fgVal) );
         // Note:  The foreground color ranges from pure red to pure
         //        white as the slider value increases from 0 to 255.
   }
}</pre>
   

<p>(The complete source code is in the file <span class="sourceref"><a href="../source/SliderAndComboBoxDemo.java">SliderAndComboBoxDemo.java</a></span>.)</p>
   

   


<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.4">6.7.4&nbsp;&nbsp;A Simple Calculator</a>
</h3>


<p>As our next example, we look briefly at an example that uses nested subpanels
to build a more complex user interface.  The program has two <span class="classname">JTextFields</span>
where the user can enter two numbers, four <span class="classname">JButtons</span> that the
user can click to add, subtract, multiply, or divide the two numbers, and
a <span class="classname">JLabel</span> that displays the result of the operation:</p>


<p align="center">
<applet code="SimpleCalc.class" width="300" height="150" archive="SimpleCalc.jar" alt="Applet 'SimpleCalc' should appear here."></applet></p>
   

<p>Like the previous example, this example uses a main panel with a
<span class="classname">GridLayout</span> that has four rows and one column.  In this
case, the layout is created with the statement:</p>
   

<pre>setLayout(new GridLayout(4,1,3,3));</pre>


<p>which allows a 3-pixel gap between the rows where the gray background color
of the panel is visible.  The gray border around the edges of the panel is
added with the statement</p>
   

<pre>setBorder( BorderFactory.createEmptyBorder(5,5,5,5) );</pre>
   

<p>The first row of the grid layout actually contains two components,
a <span class="classname">JLabel</span> displaying the text "<span class="code">x&nbsp;=</span>"
and a <span class="classname">JTextField</span>.  A grid layout can only only
have one component in each position.  In this case, that component
is a <span class="classname">JPanel</span>, a subpanel that is nested inside
the main panel.  This subpanel in turn contains the label and text
field.  This can be programmed as follows:</p>
   

<pre>xInput = new JTextField("0", 10); // Create a text field sized to hold 10 chars.
JPanel xPanel = new JPanel();     // Create the subpanel.
xPanel.add( new JLabel(" x = ")); // Add a label to the subpanel.
xPanel.add(xInput);               // Add the text field to the subpanel
mainPanel.add(xPanel);            // Add the subpanel to the main panel.</pre>


<p>The subpanel uses the default <span class="classname">FlowLayout</span> layout manager,
so the label and text field are simply placed next to each other in the
subpanel at their preferred size, and are centered in the subpanel.</p>
   

<p>Similarly, the third row of the grid layout is a subpanel that contains four
buttons.  In this case, the subpanel uses a <span class="classname">GridLayout</span> with
one row and four columns, so that the buttons are all the same size and completely
fill the subpanel.</p>
   

<p>One other point of interest in this example is the <span class="code">actionPerformed()</span>
method that responds when the user clicks one of the buttons.  This method must
retrieve the user's numbers from the text field, perform the appropriate 
arithmetic operation on them (depending on which button was clicked), and
set the text of the label to represent the result.  However, the contents of
the text fields can only be retrieved as strings, and these strings must be
converted into numbers.  If the conversion fails, the label is set to display 
an error message:</p>
   

<pre>public void actionPerformed(ActionEvent evt) {
   
   double x, y;  // The numbers from the input boxes.
   
   try {
      String xStr = xInput.getText();
      x = Double.parseDouble(xStr);
   }
   catch (NumberFormatException e) {
          // The string xStr is not a legal number.
      answer.setText("Illegal data for x.");
      xInput.requestFocus();
      return;
   }
   
   try {
      String yStr = yInput.getText();
      y = Double.parseDouble(yStr);
   }
   catch (NumberFormatException e) {
         // The string yStr is not a legal number.
      answer.setText("Illegal data for y.");
      yInput.requestFocus();
      return;
   }
   
   /* Perfrom the operation based on the action command from the
    button.  The action command is the text displayed on the button.
    Note that division by zero produces an error message. */
   
   String op = evt.getActionCommand();
   if (op.equals("+"))
      answer.setText( "x + y = " + (x+y) );
   else if (op.equals("-"))
      answer.setText( "x - y = " + (x-y) );
   else if (op.equals("*"))
      answer.setText( "x * y = " + (x*y) );
   else if (op.equals("/")) {
      if (y == 0)
         answer.setText("Can't divide by zero!");
      else
         answer.setText( "x / y = " + (x/y) );
   }
   
} // end actionPerformed()</pre>
   

<p>(The complete source code for this example can be found in <span class="sourceref"><a href="../source/SimpleCalc.java">SimpleCalc.java</a></span>.)</p>


   

   

<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.5">6.7.5&nbsp;&nbsp;Using a null Layout</a>
</h3>



<p>As mentioned above, it is possible to do without a layout manager altogether.
For out next example, we'll look at a panel that does not use a layout
manager.  If you set the layout manager of a container to be <span class="code">null</span>, 
by calling <span class="code">container.setLayout(null)</span>, then
you assume complete responsibility for positioning and sizing the components in
that container.</p>


<p>If <span class="code">comp</span> is any component, then the statement</p>


<pre>comp.setBounds(x, y, width, height);</pre>


<p>puts the top left corner of the component at the point <span class="code">(x,y)</span>,
measured in the coordinate system of the container that contains the
component, and it sets the width and height of the component to the specified
values. You should only set the bounds of a component if the container that
contains it has a null layout manager. In a container that has a non-null
layout manager, the layout manager is responsible for setting the bounds, and
you should not interfere with its job.</p>


<p>Assuming that you have set the layout manager to <span class="code">null</span>, you can call
the <span class="code">setBounds()</span> method any time you like. (You can even make a
component that moves or changes size while the user is watching.) If you are
writing a panel that has a known, fixed size, then you can set the bounds of
each component in the panel's constructor.  Note that you must also add
the components to the panel, using the panel's <span class="code">add(component)</span>
instance method; otherwise, the component will not appear on the screen.</p>
   

<p>Our example contains four components: two buttons, a label, and a
panel that displays a checkerboard pattern:</p>


<p align="center">
<applet code="NullLayoutDemo.class" width="350" height="240" archive="NullLayoutDemo.jar" alt="(Applet 'NullLayoutDemo' should be displayed here.)"></applet></p>
   

<p>This is just an example of using a null layout; it doesn't do anything,
except that clicking the buttons changes the text of the label. (We will use
this example in <a href="../c7/s5.html">Section&nbsp;7.5</a> as a starting point for a checkers game.)</p>


<p>For its content pane, this example uses a main panel that is defined by a class named
<span class="classname">NullLayoutPanel</span>.  The four
components are created and added to the panel in the constructor of the
<span class="classname">NullLayoutPanel</span> class.
Then the <span class="code">setBounds()</span> method of each component is
called to set the size and position of the component:</p>


<pre>public NullLayoutPanel() {
   
   setLayout(null);  // I will do the layout myself!
   
   setBackground(new Color(0,150,0));  // A dark green background.
   
   setBorder( BorderFactory.createEtchedBorder() ); 
   
   setPreferredSize( new Dimension(350,240) );
        // I assume that the size of the panel is, in fact, 350-by-240.
   
   /* Create the components and add them to the content pane.  If you
    don't add them to the a container, they won't appear, even if
    you set their bounds! */
   
   board = new Checkerboard();
       // (Checkerborad is a subclass of JPanel, defined elsewhere.)
   add(board);
   
   newGameButton = new JButton("New Game");
   newGameButton.addActionListener(this);
   add(newGameButton);
   
   resignButton = new JButton("Resign");
   resignButton.addActionListener(this);
   add(resignButton);
   
   message = new JLabel("Click \"New Game\" to begin a game.");
   message.setForeground( new Color(100,255,100) ); // Light green.
   message.setFont(new Font("Serif", Font.BOLD, 14));
   add(message);
   
   /* Set the position and size of each component by calling
    its setBounds() method. */
   
   board.setBounds(20,20,164,164);
   newGameButton.setBounds(210, 60, 120, 30);
   resignButton.setBounds(210, 120, 120, 30);
   message.setBounds(20, 200, 330, 30);
            
} // end constructor</pre>


<p>It's reasonably easy, in this case, to get an attractive layout. It's much
more difficult to do your own layout if you want to allow for changes of size.
In that case, you have to respond to changes in the container's size by
recomputing the sizes and positions of all the components that it contains. If
you want to respond to changes in a container's size, you can register an
appropriate listener with the container. Any component generates an event of
type <span class="code">ComponentEvent</span> when its size changes (and also when it is moved,
hidden, or shown). You can register a <span class="code">ComponentListener</span> with the
container and respond to size change events by recomputing the sizes and
positions of all the components in the container. Consult a Java reference for
more information about <span class="code">ComponentEvents</span>. However, my real advice is
that if you want to allow for changes in the container's size, try to find a
layout manager to do the work for you.</p>


<p>(The complete source code for this example is in <span class="sourceref"><a href="../source/NullLayoutDemo.java">NullLayoutDemo.java</a></span>.)</p>





<hr class="break">
<h3 class="subsection_title">
<a name="GUI1.7.6">6.7.6&nbsp;&nbsp;A Little Card Game</a>
</h3>
   


<p>For a final example, let's look at something a little more interesting as a program.
The example is a simple card game in which you look at a playing card and try to
predict whether the next card will be higher or lower in value. (Aces have the
lowest value in this game.) You've seen a text-oriented version of the same
game in <a href="../c5/s4.html#OOP.4.3">Subsection&nbsp;5.4.3</a>. <a href="../c5/s4.html">Section&nbsp;5.4</a> also introduced
<span class="classname">Deck</span>, <span class="classname">Hand</span>, and <span class="classname">Card</span> 
classes that are used in the game program. In this GUI version of the game, 
you click on a button to make your
prediction. If you predict wrong, you lose. If you make three correct
predictions, you win. After completing one game, you can click the "New Game"
button to start a new game. Try it! See what happens if you click on one of the
buttons at a time when it doesn't make sense to do so.</p>


<p align="center">
<applet code="HighLowGUI$Applet.class" width="376" height="220" archive="HighLowGUI.jar" alt="Applet 'HighLowGUI$Applet' should appear here"></applet></p>
   

<p>The complete source code for this example is in the file
<span class="sourceref"><a href="../source/HighLowGUI.java">HighLowGUI.java</a></span>.</p>
   

<p>The overall structure of the main panel in this example should be clear:
It has three buttons in a subpanel at the bottom of the main panel and a large drawing
surface that displays the cards and a message.  The main panel uses a
<span class="classname">BorderLayout</span>.  The drawing surface occupies the
<span class="code">CENTER</span> position of the border layout.  The subpanel that contains
the buttons occupies the <span class="code">SOUTH</span> position of the border layout,
and the other three positions of the layout are empty.</p>
   

<p>The drawing surface is defined by a nested class named <span class="classname">CardPanel</span>,
which is a subclass of <span class="classname">JPanel</span>.  I have chosen to let the
drawing surface object do most of the work of the game: It listens for
events from the three buttons and responds by taking the appropriate actions.
The main panel is defined by <span class="classname">HighLowGUI</span> itself, which
is another subclass of <span class="classname">JPanel</span>.  The constructor
of the <span class="classname">HighLowGUI</span> class creates all the other
components, sets up event handling, and lays out the components:</p>


<pre>public HighLowGUI() {   // The constructor.
            
   setBackground( new Color(130,50,40) );
   
   setLayout( new BorderLayout(3,3) );  // BorderLayout with 3-pixel gaps.
   
   CardPanel board = new CardPanel();  // Where the cards are drawn.
   add(board, BorderLayout.CENTER);
   
   JPanel buttonPanel = new JPanel();  // The subpanel that holds the buttons.
   buttonPanel.setBackground( new Color(220,200,180) );
   add(buttonPanel, BorderLayout.SOUTH);
   
   JButton higher = new JButton( "Higher" );
   higher.addActionListener(board);   // The CardPanel listens for events.
   buttonPanel.add(higher);
   
   JButton lower = new JButton( "Lower" );
   lower.addActionListener(board);
   buttonPanel.add(lower);
   
   JButton newGame = new JButton( "New Game" );
   newGame.addActionListener(board);
   buttonPanel.add(newGame);
   
   setBorder(BorderFactory.createLineBorder( new Color(130,50,40), 3) );
   
}  // end constructor</pre>
   
   

<p>The programming of the drawing surface class, <span class="classname">CardPanel</span>,
is a nice example of thinking in terms of a state machine.  (See <a href="../c6/s5.html#GUI1.5.4">Subsection&nbsp;6.5.4</a>.)
It is important to think in terms of the states that the game can be in, how the
state can change, and how the response to events can depend on the state. The
approach that produced the original, text-oriented game in 
<a href="../c5/s4.html#OOP.4.3">Subsection&nbsp;5.4.3</a> is not appropriate here. Trying to think about
the game in terms of a process that goes step-by-step from beginning to end is
more likely to confuse you than to help you.</p>


<p>The state of the game includes the cards and the message. The cards are
stored in an object of type <span class="classname">Hand</span>. 
The message is a <span class="classname">String</span>.
These values are stored in instance variables. There is also another, less
obvious aspect of the state: Sometimes a game is in progress, and the user is
supposed to make a prediction about the next card. Sometimes we are between
games, and the user is supposed to click the "New Game" button. It's a good
idea to keep track of this basic difference in state. The <span class="classname">CardPanel</span> class uses a
boolean instance variable named <span class="code">gameInProgress</span> for this purpose.</p>


<p>The state of the game can change whenever the user clicks on a button. The
<span class="classname">CardPanel</span> class implements the <span class="code">ActionListener</span> interface
and defines an <span class="code">actionPerformed()</span> method to respond to the user's
clicks. This method simply calls one of three other methods,
<span class="code">doHigher()</span>, <span class="code">doLower()</span>, or <span class="code">newGame()</span>, depending on
which button was pressed. It's in these three event-handling methods that the
action of the game takes place.</p>


<p>We don't want to let the user start a new game if a game is currently in
progress. That would be cheating. So, the response in the <span class="code">newGame()</span>
method is different depending on whether the state variable
<span class="code">gameInProgress</span> is true or false. If a game is in progress, the
<span class="code">message</span> instance variable should be set to show an error message. If a
game is not in progress, then all the state variables should be set to
appropriate values for the beginning of a new game. In any case, the board must
be repainted so that the user can see that the state has changed. The complete
<span class="code">newGame()</span> method is as follows:</p>


<pre>/**
 * Called by the CardPanel constructor, and called by actionPerformed() if
 * the user clicks the "New Game" button.  Start a new game.
 */
void doNewGame() {
   if (gameInProgress) {
         // If the current game is not over, it is an error to try
         // to start a new game.
      message = "You still have to finish this game!";
      repaint();
      return;
   }
   deck = new Deck();   // Create the deck and hand to use for this game.
   hand = new Hand();
   deck.shuffle();
   hand.addCard( deck.dealCard() );  // Deal the first card into the hand.
   message = "Is the next card higher or lower?";
   gameInProgress = true;
   repaint();
} // end doNewGame()</pre>


<p>The <span class="code">doHigher()</span> and <span class="code">doLower()</span> methods are almost identical
to each other (and could probably have been combined into one method with a
parameter, if I were more clever). Let's look at the <span class="code">doHigher()</span>
routine. This is called when the user clicks the "Higher" button. This only
makes sense if a game is in progress, so the first thing <span class="code">doHigher()</span>
should do is check the value of the state variable <span class="code">gameInProgress</span>. If
the value is <span class="code">false</span>, then <span class="code">doHigher()</span> should just set up an
error message. If a game is in progress, a new card should be added to the hand
and the user's prediction should be tested. The user might win or lose at this
time. If so, the value of the state variable <span class="code">gameInProgress</span> must be
set to <span class="code">false</span> because the game is over. In any case, the board is
repainted to show the new state. Here is the <span class="code">doHigher()</span> method:</p>


<pre>/**
 * Called by actionPerformmed() when user clicks "Higher" button.
 * Check the user's prediction.  Game ends if user guessed
 * wrong or if the user has made three correct predictions.
 */
void doHigher() {
   if (gameInProgress == false) {
         // If the game has ended, it was an error to click "Higher",
         // So set up an error message and abort processing.
      message = "Click \"New Game\" to start a new game!";
      repaint();
      return;
   }
   hand.addCard( deck.dealCard() );     // Deal a card to the hand.
   int cardCt = hand.getCardCount();
   Card thisCard = hand.getCard( cardCt - 1 );  // Card just dealt.
   Card prevCard = hand.getCard( cardCt - 2 );  // The previous card.
   if ( thisCard.getValue() &lt; prevCard.getValue() ) {
      gameInProgress = false;
      message = "Too bad! You lose.";
   }
   else if ( thisCard.getValue() == prevCard.getValue() ) {
      gameInProgress = false;
      message = "Too bad!  You lose on ties.";
   }
   else if ( cardCt == 4) {
      gameInProgress = false;
      message = "You win!  You made three correct guesses.";
   }
   else {
      message = "Got it right!  Try for " + cardCt + ".";
   }
   repaint();
} // end doHigher()</pre>


<p>The <span class="code">paintComponent()</span> method of the <span class="classname">CardPanel</span> class
uses the values in the state variables to decide what to show. It displays the
string stored in the <span class="code">message</span> variable. It draws each of the cards in
the <span class="code">hand</span>. There is one little tricky bit: If a game is in progress, it
draws an extra face-down card, which is not in the hand, to represent the next
card in the deck. Drawing the cards requires some care and computation. I wrote
a method, "<span class="code">void drawCard(Graphics g, Card card, int x, int y)</span>", which
draws a card with its upper left corner at the point <span class="code">(x,y)</span>. The
<span class="code">paintComponent()</span> routine decides where to draw each card and calls
this routine to do the drawing. You can check out all the details in the source
code, <span class="sourceref"><a href="../source/HighLowGUI.java">HighLowGUI.java</a></span>.</p>


<hr class="break">
   

<p>One further note on the programming of this example:
The source code  defines <span class="classname">HighLowGUI</span> as a
subclass of <span class="classname">JPanel</span>.  The class contains a
<span class="code">main()</span> routine so that it can be run as a stand-alone
application; the <span class="code">main()</span> routine simply opens a window
that uses a panel of type <span class="classname">HighLowGUI</span> as its
content pane.  In addition, I decided to write an applet version
of the program as a static nested class named <span class="classname">Applet</span>
inside the <span class="classname">HighLowGUI</span> class.  Since this is
a nested class, its full name is <span class="classname">HighLowGUI.Applet</span>
and the class file that is produced when the source code is compiled
is named <span class="code">HighLowGUI$Applet.class</span>.  This class is used for
the applet version of the program shown above.  The &lt;applet&gt; tag lists the class file
for the applet as <span class="code">code="HighLowGUI$Applet.class"</span>.
This is admittedly an unusual way to organize
the program, and it is probably more natural to have the panel, applet,
and stand-alone program defined in separate classes.  However, writing the
program in this way does show the flexibility of Java classes. (Nested classes were discussed in
<a href="../c5/s7.html#OOP.7.2">Subsection&nbsp;5.7.2</a>.)</p>

   


   

   
  

</div>
<hr>
<div align="right">
<small>
        [  <a href="s6.html">Previous Section</a> |
           <a href="s8.html">Next Section</a> |
           <a href="index.html">Chapter Index</a> | 
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
